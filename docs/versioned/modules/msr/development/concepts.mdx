---
sidebar_position: 1
sidebar_label: Concepts
---

# Concepts

import architectureDiagram from "/img/modules/msr/architecture.png";
import snapshotDiagram from "/img/modules/msr/snapshot-reconstruction.png";
import Image from "@theme/IdealImage";

This document explains the key concepts, architectural patterns, and terminology used in the MSR (Multi-Session Replay) module.

## Core Architecture

<div className="centerize">
	<div style={{ maxWidth: "800px" }}>
		<Image img={architectureDiagram} />
	</div>
</div>
<caption className="diagram">MSR Architecture Overview</caption>

The MSR module is built around a **Change Data Capture (CDC)** architecture that allows developers to record database table states and replay them at any point in time. This approach enables detailed After Action Reviews (AARs) by providing complete historical visibility into system state changes.

## Change Data Capture (CDC)

**Change Data Capture** is the foundational pattern used by MSR to track historical state changes. Unlike Event Sourcing, CDC is minimally invasive and can be retrofitted onto existing systems without architectural changes.

### Key Characteristics

-   **Non-invasive**: CDC acts as an external observer, monitoring database transaction logs
-   **Source of truth**: The primary database remains the definitive source for current state
-   **Historical accuracy**: Provides an unassailable record of what data changed and when
-   **Broad compatibility**: Can be applied to existing state-based systems

## Session Management

### Session

A **session** in MSR represents a replay instance where users can view system state at a specific point in time. Sessions are managed to balance system resources and user experience.

### Session Lifecycle

-   **Creation**: Users request a new session to replay historical data
-   **Active**: Session is actively being used for data replay
-   **Inactive**: Session is idle but still consuming resources
-   **Terminated**: Session is closed and resources are freed

:::note
In the sample session management page implementation, you will only see "active" and "inactive" states, these do not
directly correspond to backend states but are simplified for user understanding.
:::

### Session Limits

The system enforces limits on concurrent sessions:

-   **MAX_ACTIVE_SESSIONS**: Global limit on total active sessions

And limits on the historical range that can be replayed:

-   **MAX_PLAYBACK_RANGE**: Maximum time range (in days) that day is available for replay

## Data Storage and Management

### TimescaleDB Integration

MSR leverages **TimescaleDB** as its time-series database backend, providing:

-   **Hypertables**: Automatic partitioning of data into time-based chunks
-   **Performance**: Optimized for high-volume time-series data ingestion
-   **SQL Compatibility**: Full PostgreSQL feature set with time-series enhancements

### Data Structure

#### CDC Events Table

Stores the raw stream of change events captured by Debezium:

```sql
CREATE TABLE msr.cdc_event (
    entity_id TEXT,
    entity_state JSONB,
    op CHAR(1), -- 'c', 'r', 'u', 'd'
    event_timestamp TIMESTAMPTZ
);
```

#### Entity Snapshots (Continuous Aggregates)

Provides baseline states at regular intervals to optimize state reconstruction:

```sql
CREATE MATERIALIZED VIEW msr.entity_snapshots
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 hour', event_timestamp) AS snapshot_time,
    entity_id,
    last(entity_state, event_timestamp) AS entity_state,
    last(op, event_timestamp) AS op
FROM msr.cdc_event
GROUP BY snapshot_time, entity_id;
```

## State Reconstruction

### Point-in-Time Reconstruction

The core capability of MSR is reconstructing the complete system state at any historical timestamp. This process combines:

1. **Latest Snapshot**: Most recent baseline before target time
2. **Delta Events**: All changes between snapshot and target time
3. **State Merging**: Combining baseline with deltas for final state

<div className="centerize">
	<div style={{ maxWidth: "600px" }}>
		<Image img={snapshotDiagram} />
	</div>
</div>
<caption className="diagram">Snapshot Reconstruction Process</caption>

### Reconstruction Algorithm

The state reconstruction follows this logic:

1. **Find Latest Snapshot**: Locate the most recent snapshot before target timestamp
2. **Collect Delta Events**: Gather all change events since the snapshot
3. **Apply Changes**: Use `DISTINCT ON` to get the latest state for each entity
4. **Filter Deletions**: Remove entities marked as deleted (`op = 'd'`)

## Data Lifecycle Management

### Dynamic Data Retention Policy

MSR implements a sophisticated, runtime-configurable data retention system that balances storage efficiency with replay capabilities. The system uses interconnected parameters that work together to maintain data integrity while optimizing performance.

#### Runtime-Configurable Parameters

The retention policy is controlled by three primary configuration parameters that can be modified without system restart:

-   **`MAX_PLAYBACK_RANGE`** (days): Defines how far back users can initiate replays
    -   Default: 7 days
    -   Purpose: Sets the historical window boundary for user access
    -   Impact: Determines the cutoff point for snapshot creation and data cleanup operations

-   **`DATA_RETENTION_CRON_EXPRESSION`**: Complete maintenance schedule
    -   Default: `'0 3 * * *'` (daily at 3 AM)
    -   Purpose: Schedules the atomic maintenance cycle that both refreshes snapshots and cleans up old data
    -   Impact: Controls when maintenance operations occur; supports dynamic schedule changes

-   **`MAX_ACTIVE_SESSIONS`**: Concurrent replay sessions limit
    -   Default: 5
    -   Purpose: Resource management and system load control
    -   Impact: Prevents system overload by limiting simultaneous replay operations

#### Developer-Level Configuration

-   **`chunk_time_interval`**: TimescaleDB partitioning interval for the `cdc_event` hypertable
    -   Default: 1 hour
    -   Purpose: Defines data chunk size for optimal query performance and storage efficiency
    -   Recommendations:
        - High volume (&gt;1000 events/hour): 1 hour
        - Medium volume (100-1000 events/hour): 4 hours
        - Low volume (&lt;100 events/hour): 1 day
    -   **Critical Warning**: Cannot be changed retroactively without rebuilding the database

#### Retention Process Flow

The retention system operates on a coordinated cycle that ensures data consistency and performance:

```
1. Calculate cutoff time: NOW - MAX_PLAYBACK_RANGE days
2. Refresh earliest snapshot: Capture all entity states at cutoff point
3. Cleanup old CDC events: Remove data older than cutoff (preserved in snapshot)
4. Switch snapshot tables: Atomically update to new baseline
```

**Data Timeline Visualization:**
```
CREATION ────→ OLD_DATA ────→ CUTOFF_POINT ←─── MAX_PLAYBACK_RANGE days ────→ NOW
                  (Cleanup)      (Snapshot)        (configurable)         (Current)
```

**Key Benefits:**
- Users can replay any point within `MAX_PLAYBACK_RANGE`
- Entity states at the boundary are preserved in snapshots
- Old CDC events are safely removed without data loss
- Query performance remains optimal
- Configuration changes automatically apply to future maintenance cycles

### Dual Snapshot Architecture

MSR uses an innovative A/B table rotation system for atomic snapshot updates:

#### Snapshot Tables
-   **`earliest_snapshot_a`** and **`earliest_snapshot_b`**: Twin tables for data rotation
-   **`snapshot_pointer`**: Control table tracking which snapshot is currently active
-   **`current_earliest_snapshot`**: View that always points to the active snapshot

#### Atomic Operations
The dual table system enables zero-downtime snapshot updates:
1. **Build Phase**: New snapshot built in inactive table while queries continue on active table
2. **Switch Phase**: Pointer atomically updated to new table in a single transaction
3. **Cleanup Phase**: Old data safely removed after switch completion

This approach eliminates race conditions and ensures queries always have consistent, point-in-time data.

### Automated Maintenance Cycles

The MSR system includes a dynamic cron scheduler that adapts to configuration changes:

#### Dynamic Scheduling
-   **Configuration-Aware**: Reads `DATA_RETENTION_CRON_EXPRESSION` from the configuration table at runtime
-   **Hot-Reload**: Updates schedule without system restart when configuration changes
-   **Self-Checking**: Validates configuration changes on each job execution
-   **Error Resilience**: Continues operations even if configuration updates fail

#### Maintenance Operations
Each maintenance cycle performs these operations atomically through the `refresh_earliest_snapshot()` database procedure:
1. **Snapshot Refresh**: Captures all entity states at the retention boundary
2. **Data Cleanup**: Removes CDC events beyond the playback range
3. **Performance Optimization**: Maintains optimal query performance through efficient data organization
4. **Comprehensive Logging**: Detailed operation logging for monitoring and troubleshooting

### Storage Optimization

#### TimescaleDB Features
-   **Hypertables**: Automatic time-based partitioning for efficient data access and maintenance
-   **Chunk Operations**: Bulk operations on time-partitioned data segments for performance
-   **Query Optimization**: Time-series specific query optimizations and indexing strategies

#### Compression
TimescaleDB's native compression provides:
-   **Storage Savings**: Often >90% reduction in storage requirements for older data
-   **Query Performance**: Improved analytical query performance on compressed chunks
-   **Automatic Management**: Policy-driven compression of older data chunks based on age

## Frontend Architecture

### Stateless Backend, Stateful Frontend

MSR employs a unique architecture where:

-   **Backend**: Stateless services that reconstruct state on-demand
-   **Frontend**: Maintains session state and manages user interactions
-   **Benefits**: Improved scalability, simplified session management, enhanced user experience

### Web Worker Integration

For performance optimization, MSR uses Web Workers to:

-   **Offload Processing**: Move heavy state management off the main UI thread
-   **Maintain Responsiveness**: Keep user interface smooth during data processing
-   **Handle Large States**: Manage memory-intensive operations efficiently

## Integration Components

### Debezium Source Connector

Monitors source databases and captures change events:

-   **PostgreSQL Connector**: Reads from transaction logs using `pgoutput`
-   **Kafka Integration**: Streams events to Kafka topics
-   **Transformation**: Applies Single Message Transforms (SMT) for data formatting

### JDBC Sink Connector

Processes Kafka events and stores them in MSR database:

-   **Batch Processing**: Optimized batch inserts for performance
-   **Data Transformation**: Formats events for TimescaleDB storage
-   **Error Handling**: Robust retry mechanisms and error recovery

## Entity Types and Operations

### Entity ID

The `entity_id` uniquely identifies each tracked entity, typically corresponding to a primary key in the source table.
It is important to note that this ID is expected to be unique within the context of a source table across all time.
However, it is not globally unique across different tables or databases.

When mapping your tables, you might have a composite key in the source table; in such cases, concatenate the key fields
into a single string to form the `entity_id`.

### Entity Operations

MSR tracks four types of database operations:

-   **`c` (Create)**: New entity insertion
-   **`r` (Read)**: Initial state capture (from snapshots)
-   **`u` (Update)**: Entity modification
-   **`d` (Delete)**: Entity removal

### Entity State Format

Entities are stored as JSONB objects and can basically represent any table structure - configure the source connector
to map your desired tables' columns into the JSONB `entity_state` field.
